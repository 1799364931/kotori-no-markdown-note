# GC

## 1 GC要解决的问题
### 1.1 在哪里进行
GC一般在方法区和堆区进行，因为两个栈和程序计数器都是随着线程的生命周期开始而开始、结束而结束，所以不会在这些地方GC。

同时由于堆区和方法区所确定的大小是程序运行的才能确定的，所以就没有办法提前分配好空间，它的内存是动态的，所以GC在这里进行。

### 1.2 什么时候回收

### 1.3 怎么回收

## 2 如何判断对象已死
### 2.1 引用计数
类似于C++的智能指针，但是会有相互引用导致无法GC的情况。

### 2.2 可达性分析
通过一个根对象来找到其引用链，如果某个对象不可达，说明对象已死。

可以作为GC root：
+ 虚拟机栈中的引用对象
+ 静态类属性引用对象
+ 常量引用对象
+ 本地方法引用对象
+ 等等

## 3 垃圾回收算法
### 3.1 分代回收理论
根据被回收对象的年龄（熬过GC周期）来分为不同的区域，以进行不同频次的垃圾回收。

+ 弱分代假说：大部分对象都是朝生夕灭的
+ 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
+ 跨代引用假说：跨代引用相对于同代引用来说仅占极少数 （可推出可以将跨代引用的对象额外划分一个数据结构(rememberd set)进行GC）

部分收集(partial gc)：分为
+ 新生代收集(minor gc/young gc)
+ 老年代收集(major gc/old gc)
+ 混合收集(mix gc)：整个新生代 + 部分老年代

整堆收集(full gc)

### 3.2 标记-清除算法：
两种实现：
1. 标记可回收，清除标记对象
2. 标记不可回收，清除非标记对象
缺点：
1. 内存间隙
2. 大量的标记开销过大

### 3.3 标记-复制算法
将区域划分为两块，每次只使用其中一块，标记不可回收的，复制到另一块内存区域，完全回收原内存区域。
缺点：
1. 不可回收的对象过多会导致复制开销大
2. 浪费内存，每次只能用一半

目前主流的内存回收算法采用了这种算法的优化版本：
apple 回收：

1. 划分1个eden 2个survivor 区域
2. 分配时分配到eden + 1个survivor区域中
3. 回收时候标记不可回收
4. 复制不可回收对象到未分配的survivor区域中
5. 清除区域
6. 当复制的对象过多的时候放不到survivor区域中后，就会触发分配担保，使其直接进入老年代区域

![image-20250824170839260](.\picture\apple-gc.png)

### 标记-整理算法
和标记-清除算法类似，但是该算法会将所有存活对象移动到一端，然后根据边界来清除可回收对象，一般用于老年代。

缺点：
1. 花销极大，但是可以有效利用空间

## 4 HotSpot 算法细节实现

### 4.1 根节点枚举

### 4.2 安全点

### 4.3 安全区域

### 4.4 记忆集与卡表

卡表是记忆集的实现方式，每一个CARD标记一个小的内存区域，如果这个CARD为1则说明该区域存在跨代指针，从而很容易地找到记忆集。



#### 4.5 写屏障 

卡表的维护也很简单，在一个对象被新对象引用的时候，直接在对应对象的内存区域的卡表赋值1即可。

写屏障优化：卡表写入前检查是否被写过。可以避免伪共享问题。


#### 4.6 并发可达性分析
三色标记
1. 白色，未扫描过的
2. 黑色，已经经过扫描且经历了GC
3. 灰色，至少有一个引用(还能至少再扩展一圈)
对象消失

满足对象消失的两个条件：
1. 黑色指向白色 (黑色无法到达白色)
2. 删除了灰色指向白色 (灰色无法到达白色)

破坏条件的解决方法：
1.【增量更新】 记录黑色指向白色的修改(记录修改后的引用)，后续将这些黑色作为根重新扫描
2.【原始快照】 记录灰色删除指向白色的修改(记录修改前的引用)，后续将这些灰色作为根重新扫描



