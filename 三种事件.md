### 三种事件

1.Hardware Event

2.Software Event

3.Tracepoint event



### perf stat   \<command\>

![image-20250120171339634](C:\Users\18316\AppData\Roaming\Typora\typora-user-images\image-20250120171339634.png)

### perf stat -e -\<event\>  \<command\>

![image-20250120172149479](C:\Users\18316\AppData\Roaming\Typora\typora-user-images\image-20250120172149479.png)

<table><tbody><tr><th> <p>序号</p> </th><th> <p>命令</p> </th><th> <p>作用</p> </th></tr><tr><td> <p>1</p> </td><td> <p><b>annotate</b></p> </td><td> <p>解析perf record生成的perf.data文件，显示被注释的代码。</p> </td></tr><tr><td> <p>2</p> </td><td> <p><b>archive</b></p> </td><td> <p>根据数据文件记录的build-id，将所有被采样到的elf文件打包。利用此压缩包，可以再任何机器上分析数据文件中记录的采样数据。</p> </td></tr><tr><td> <p>3</p> </td><td> <p>bench</p> </td><td> <p>perf中内置的benchmark，目前包括两套针对调度器和<span class="edu-hl hl hl-1" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;word\&quot;:\&quot;内存管理\&quot;}&quot;}" data-tit="内存管理" data-pretit="内存管理">内存管理</span>子系统的benchmark。</p> </td></tr><tr><td> <p>4</p> </td><td> <p>buildid-cache</p> </td><td> <p>管理perf的buildid缓存，每个elf文件都有一个独一无二的buildid。buildid被perf用来关联性能数据与elf文件。</p> </td></tr><tr><td> <p>5</p> </td><td> <p>buildid-list</p> </td><td> <p>列出数据文件中记录的所有buildid。</p> </td></tr><tr><td> <p>6</p> </td><td> <p>diff</p> </td><td> <p>对比两个数据文件的差异。能够给出每个符号（函数）在热点分析上的具体差异。</p> </td></tr><tr><td> <p>7</p> </td><td> <p>evlist</p> </td><td> <p>列出数据文件perf.data中所有性能事件。</p> </td></tr><tr><td> <p>8</p> </td><td> <p>inject</p> </td><td> <p>该工具读取perf record工具记录的事件流，并将其定向到标准输出。在被分析代码中的任何一点，都可以向事件流中注入其它事件。</p> </td></tr><tr><td> <p>9</p> </td><td> <p>kmem</p> </td><td> <p>针对内核内存（slab）子系统进行追踪测量的工具</p> </td></tr><tr><td> <p>10</p> </td><td> <p>kvm</p> </td><td> <p>用来追踪测试运行在KVM<span class="words-blog hl-git-1" data-tit="虚拟机" data-pretit="虚拟机">虚拟机</span>上的Guest OS。</p> </td></tr><tr><td> <p>11</p> </td><td> <p>list</p> </td><td> <p>列出当前系统支持的所有性能事件。包括硬件性能事件、软件性能事件以及检查点。</p> </td></tr><tr><td> <p>12</p> </td><td> <p>lock</p> </td><td> <p>分析内核中的锁信息，包括锁的争用情况，等待延迟等。</p> </td></tr><tr><td> <p>13</p> </td><td> <p>mem</p> </td><td> <p>内存存取情况</p> </td></tr><tr><td> <p>14</p> </td><td> <p>record</p> </td><td> <p>收集采样信息，并将其记录在数据文件中。随后可通过其它工具对数据文件进行分析。</p> </td></tr><tr><td> <p>15</p> </td><td> <p>report</p> </td><td> <p>读取perf record创建的数据文件，并给出热点分析结果。</p> </td></tr><tr><td> <p>16</p> </td><td> <p>sched</p> </td><td> <p>针对调度器子系统的分析工具。</p> </td></tr><tr><td> <p>17</p> </td><td> <p>script</p> </td><td> <p>执行perl或python写的功能扩展脚本、生成脚本框架、读取数据文件中的数据信息等。</p> </td></tr><tr><td> <p>18</p> </td><td> <p>stat</p> </td><td> <p>执行某个命令，收集特定进程的性能概况，包括CPI、Cache丢失率等。</p> </td></tr><tr><td> <p>19</p> </td><td> <p>test</p> </td><td> <p>perf对当前软硬件平台进行健全性测试，可用此工具测试当前的软硬件平台是否能支持perf的所有功能。</p> </td></tr><tr><td> <p>20</p> </td><td> <p>timechart</p> </td><td> <p>针对测试期间系统行为进行可视化的工具</p> </td></tr><tr><td> <p>21</p> </td><td> <p>top</p> </td><td> <p>类似于linux的top命令，对系统性能进行实时分析。</p> </td></tr><tr><td> <p>22</p> </td><td> <p>trace</p> </td><td> <p>关于syscall的工具。</p> </td></tr><tr><td> <p>23</p> </td><td> <p>probe</p> </td><td> <p>用于定义动态检查点。</p> </td></tr></tbody></table>

`` perf annotate -s <symbol> ``

### perf record

- **`-o <file>`**：指定输出文件名（默认是 `perf.data`）。

  ```
  perf record -o my_perf.data ./your_program
  ```

- **`-g`**：记录调用图（call graph）信息，用于分析函数调用关系。

  ```
  perf record -g ./your_program
  ```

- **`-p <pid>`**：附加到指定进程 ID 的进程进行采样。

  ```
  perf record -p 1234
  ```

- **`-F <frequency>`**：设置采样频率（每秒采样次数）。(采样频率越高可以获得越精确的数据，但是perf本身的运行可能也会影响到数据？同时采样频率高才能在使用``perf annotate``中读取到运行时间较短的函数)

  ```
  perf record -F 1000 ./your_program  # 每秒采样 1000 次
  ```

- **`-c <count>`**：设置采样周期（每发生多少次事件采样一次）。

  ```
  perf record -c 10000 ./your_program  # 每 10000 个事件采样一次
  ```

- **`-e <event>`**：指定要采样的事件（默认是 `cycles`）。

  ```
  perf record -e cache-misses ./your_program  # 采样缓存未命中事件
  ```



### perf report 

![image-20250125172044079](C:\Users\18316\AppData\Roaming\Typora\typora-user-images\image-20250125172044079.png)

Samples：采样个数
Event count：系统总共发生的事件数
Symbol：函数名，其中 [.] 表示用户空间函数，[k] 表示内核函数
Shared Objec：函数所在的共享库或所在的程序
Command：进程名
Self：该函数的 CPU 使用率
Children：该函数的子函数的 CPU 使用率

(如果self很小但是children很多，说明子函数占用的最多)

``sudo LD_LIBRARY_PATH="$HOME/openssl/install/lib:$LD_LIBRARY_PATH" perf record -g -F 50570 -e hit_on_prf ./sm4_encrypt``



``g++ sm4_encrypt.cpp -o sm4_encrypt \
    -I$HOME/openssl/install/include \
    -L$HOME/openssl/install/lib \
    -lssl -lcrypto``





``export PATH="$HOME/openssl/install/bin:$PATH"
export LD_LIBRARY_PATH="$HOME/openssl/install/lib:$LD_LIBRARY_PATH"``

```cpp
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/err.h> // 添加 ERR 相关头文件
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 错误处理函数
void handle_errors() {
    fprintf(stderr, "Error occurred\n");
    ERR_print_errors_fp(stderr); // 打印 OpenSSL 错误信息
    exit(1);
}

int main() {
    // 初始化 OpenSSL 库
    OpenSSL_add_all_algorithms();
    OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, nullptr); // 替换 ERR_load_crypto_strings

    // 读取明文文件
    FILE *plaintext_file = fopen("testfile.txt", "rb");
    if (!plaintext_file) {
        perror("Failed to open plaintext.txt");
        return 1;
    }

    // 获取文件大小
    fseek(plaintext_file, 0, SEEK_END);
    long plaintext_len = ftell(plaintext_file);
    fseek(plaintext_file, 0, SEEK_SET);

    // 读取明文数据
    unsigned char *plaintext = (unsigned char *)malloc(plaintext_len); // 显式类型转换
    if (!plaintext) {
        perror("Failed to allocate memory");
        fclose(plaintext_file);
        return 1;
    }
    fread(plaintext, 1, plaintext_len, plaintext_file);
    fclose(plaintext_file);

    // 设置 SM4 密钥和 IV
    unsigned char key[16]; // SM4 密钥长度为 128 位（16 字节）
    unsigned char iv[16];  // IV 长度为 128 位（16 字节）

    // 生成随机密钥和 IV
    if (!RAND_bytes(key, sizeof(key)) || !RAND_bytes(iv, sizeof(iv))) {
        handle_errors();
    }

    // 创建加密上下文
     EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        handle_errors();
    }

    // 初始化加密操作
    if (1 != EVP_EncryptInit_ex(ctx, EVP_sm4_cbc(), NULL, key, iv)) {
        handle_errors();
    }

    // 输出缓冲区
    unsigned char ciphertext[plaintext_len + 16]; // 密文长度可能比明文长一个块
    int ciphertext_len;
    int len;

    // 加密数据
    if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {
        handle_errors();
    }
    ciphertext_len = len;

    // 结束加密
    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {
        handle_errors();
    }
    ciphertext_len += len;

    // 清理上下文
    EVP_CIPHER_CTX_free(ctx);

    // 将密文写入文件
    FILE *out_file = fopen("out.txt", "wb");
    if (!out_file) {
        perror("Failed to open out.txt");
        free(plaintext);
        return 1;
    }
    fwrite(ciphertext, 1, ciphertext_len, out_file);
    fclose(out_file);

    // 释放内存
    free(plaintext);

    // 清理 OpenSSL 库
    EVP_cleanup();
    // ERR_free_strings(); // OpenSSL 3.0 不再需要手动释放错误字符串

    printf("Encryption completed. Ciphertext saved to out.txt\n");
    return 0;
}                                                      
```

