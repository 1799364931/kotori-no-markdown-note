# lecture 20  database log

## 1.why we need log？

- 保证提交后的持久化
- 避免局部提交(即某个事务提交后，其对应页刷盘，但是页中存在未提交事务的更改)
- 快速恢复，当系统崩溃后可以重放或撤回操作，如果没有日志系统，在系统崩溃的时候就存在局部事务完成，无法做对应的回滚和重放

## 2.buffer policy 缓冲池策略

STEAL / NO-STEAL => 允许 / 不允许 未提交的事务持久化

FORCE / NO-FORCE => 事务提交后 立即 / 暂缓 持久化

## 3.shadow page 影子分页

以 NO-STEAL + FORCE 为策略，每次事务运行时，对其需要读取的页进行影子页复制，操作的时候就操作影子页，事务提交时，修改页指针指向影子页

好处：对于未提交事务不用 undo ；对于已提交事务不用 redo 。恢复快，在crash的过程中，如果需要恢复就直接读取影子页，如果不需要恢复直接删除影子页。

坏处：频繁复制开销大

## 4.writed-ahead log 预写日志

以 STEAL + NO-FORCE 为策略，每次执行时，日志=>日志buffer=>日志持久化(可以进行组commit/timeout commit)=>页buffer=>页持久化。

只有当日志确认落盘后，再对日志相关的页进行操作

好处：开销小

坏处：恢复时候需要撤销未提交事务的操作，重放已提交事务的操作

## 5.log schema

日志记录格式

记录物理位置(page offset)

记录逻辑查询(记录sql语句)

混合记录

## 6.checkpoints

由于日志需要落盘后才能进行持久化写入，为了避免日志积累过多，导致回滚和日志应用的时间过长，可以适当执行checkpoint，在checkpoint开始后停止所有事务，进行持久化。



**question:**

1.project 1 是什么策略 ， 能否实现持久化，如何保证写入性？

2.如果在日志写入到一半的过程中crash掉了，怎么记录并进行恢复？(怎么知道写了哪些)

3.日志buffer的刷盘和页buffer的刷盘如何进行协调？

4.日志的好处在哪？(相比于直接写磁盘)